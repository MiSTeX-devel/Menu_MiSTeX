/* Generated by Yosys 0.17 (git sha1 6f9602b4c, gcc 11.3.0-1ubuntu1~22.04 -fPIC -Os) */

module sck_divider(clock_enable_in, rst, clk, clock_out);
  reg \$auto$verilog_backend.cc:2083:dump_module$17  = 0;
  wire \$1 ;
  wire \$3 ;
  wire \$5 ;
  wire [2:0] \$7 ;
  wire [2:0] \$8 ;
  input clk;
  wire clk;
  reg [1:0] clock_counter = 2'h0;
  reg [1:0] \clock_counter$next ;
  input clock_enable_in;
  wire clock_enable_in;
  output clock_out;
  reg clock_out = 1'h0;
  reg \clock_out$next ;
  input rst;
  wire rst;
  assign \$1  = clock_counter >= 2'h2;
  assign \$3  = ~ clock_out;
  assign \$5  = clock_counter >= 2'h2;
  assign \$8  = clock_counter + 1'h1;
  always @(posedge clk)
    clock_counter <= \clock_counter$next ;
  always @(posedge clk)
    clock_out <= \clock_out$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    \clock_out$next  = clock_out;
    casez (\$1 )
      1'h1:
          (* full_case = 32'd1 *)
          casez (clock_enable_in)
            1'h1:
                \clock_out$next  = \$3 ;
            default:
                \clock_out$next  = 1'h0;
          endcase
    endcase
    casez (rst)
      1'h1:
          \clock_out$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$17 ) begin end
    (* full_case = 32'd1 *)
    casez (\$5 )
      1'h1:
          \clock_counter$next  = 2'h0;
      default:
          \clock_counter$next  = \$8 [1:0];
    endcase
    casez (rst)
      1'h1:
          \clock_counter$next  = 2'h0;
    endcase
  end
  assign \$7  = \$8 ;
endmodule

module spi_device(spi_device__sdi, spi_device__sck, spi_device__cs, word_in, word_out, word_accepted, word_complete, rst, clk, spi_device__sdo);
  reg \$auto$verilog_backend.cc:2083:dump_module$18  = 0;
  wire \$1 ;
  wire \$11 ;
  wire [6:0] \$13 ;
  wire \$15 ;
  wire \$17 ;
  wire \$19 ;
  wire \$21 ;
  wire \$23 ;
  wire \$25 ;
  wire [6:0] \$27 ;
  wire \$29 ;
  wire \$3 ;
  wire \$31 ;
  wire \$33 ;
  wire \$35 ;
  wire \$37 ;
  wire [6:0] \$39 ;
  wire [6:0] \$40 ;
  wire \$42 ;
  wire \$44 ;
  wire \$46 ;
  wire \$48 ;
  wire \$5 ;
  wire \$7 ;
  wire \$9 ;
  (* \amaranth.sample_reg  = 32'd1 *)
  reg \$sample$s$chip_selected$sync$1  = 1'h0;
  wire \$sample$s$chip_selected$sync$1$next ;
  (* \amaranth.sample_reg  = 32'd1 *)
  reg \$sample$s$serial_clock$sync$1  = 1'h0;
  wire \$sample$s$serial_clock$sync$1$next ;
  reg [5:0] bit_count = 6'h00;
  reg [5:0] \bit_count$next ;
  wire chip_selected;
  input clk;
  wire clk;
  reg [39:0] current_rx = 40'h0000000000;
  reg [39:0] \current_rx$next ;
  reg [39:0] current_tx = 40'h0000000000;
  reg [39:0] \current_tx$next ;
  reg is_first_bit = 1'h0;
  reg \is_first_bit$next ;
  wire \output ;
  input rst;
  wire rst;
  wire sample;
  wire serial_clock;
  input spi_device__cs;
  wire spi_device__cs;
  input spi_device__sck;
  wire spi_device__sck;
  input spi_device__sdi;
  wire spi_device__sdi;
  output spi_device__sdo;
  reg spi_device__sdo = 1'h0;
  reg \spi_device__sdo$next ;
  output word_accepted;
  reg word_accepted = 1'h0;
  reg \word_accepted$next ;
  output word_complete;
  reg word_complete = 1'h0;
  reg \word_complete$next ;
  output [39:0] word_in;
  reg [39:0] word_in = 40'h0000000000;
  reg [39:0] \word_in$next ;
  input [39:0] word_out;
  wire [39:0] word_out;
  assign \$9  = ~ \$sample$s$serial_clock$sync$1 ;
  assign \$11  = \$9  & serial_clock;
  assign \$13  = bit_count + 1'h1;
  assign \$15  = \$13  == 6'h28;
  assign \$17  = ~ spi_device__cs;
  assign \$1  = ~ \$sample$s$serial_clock$sync$1 ;
  assign \$19  = ~ \$sample$s$chip_selected$sync$1 ;
  assign \$21  = \$19  & chip_selected;
  assign \$23  = ~ \$sample$s$serial_clock$sync$1 ;
  assign \$25  = \$23  & serial_clock;
  assign \$27  = bit_count + 1'h1;
  assign \$29  = \$27  == 6'h28;
  assign \$31  = ~ serial_clock;
  assign \$33  = \$sample$s$serial_clock$sync$1  & \$31 ;
  assign \$35  = ~ \$sample$s$serial_clock$sync$1 ;
  assign \$37  = \$35  & serial_clock;
  assign \$3  = \$1  & serial_clock;
  assign \$40  = bit_count + 1'h1;
  assign \$42  = ~ \$sample$s$serial_clock$sync$1 ;
  assign \$44  = \$42  & serial_clock;
  assign \$46  = ~ \$sample$s$serial_clock$sync$1 ;
  assign \$48  = \$46  & serial_clock;
  assign \$5  = ~ serial_clock;
  assign \$7  = \$sample$s$serial_clock$sync$1  & \$5 ;
  always @(posedge clk)
    current_tx <= \current_tx$next ;
  always @(posedge clk)
    spi_device__sdo <= \spi_device__sdo$next ;
  always @(posedge clk)
    word_accepted <= \word_accepted$next ;
  always @(posedge clk)
    word_complete <= \word_complete$next ;
  always @(posedge clk)
    word_in <= \word_in$next ;
  always @(posedge clk)
    \$sample$s$chip_selected$sync$1  <= \$17 ;
  always @(posedge clk)
    \$sample$s$serial_clock$sync$1  <= spi_device__sck;
  always @(posedge clk)
    current_rx <= \current_rx$next ;
  always @(posedge clk)
    is_first_bit <= \is_first_bit$next ;
  always @(posedge clk)
    bit_count <= \bit_count$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$18 ) begin end
    \is_first_bit$next  = is_first_bit;
    (* full_case = 32'd1 *)
    casez (chip_selected)
      1'h1:
          casez (\$44 )
            1'h1:
                \is_first_bit$next  = 1'h0;
          endcase
      default:
          \is_first_bit$next  = 1'h1;
    endcase
    casez (rst)
      1'h1:
          \is_first_bit$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$18 ) begin end
    \current_rx$next  = current_rx;
    casez (chip_selected)
      1'h1:
          casez (\$48 )
            1'h1:
                \current_rx$next  = { current_rx[38:0], spi_device__sdi };
          endcase
    endcase
    casez (rst)
      1'h1:
          \current_rx$next  = 40'h0000000000;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$18 ) begin end
    \word_in$next  = word_in;
    casez (word_accepted)
      1'h1:
          \word_in$next  = current_rx;
    endcase
    casez (rst)
      1'h1:
          \word_in$next  = 40'h0000000000;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$18 ) begin end
    (* full_case = 32'd1 *)
    casez (word_accepted)
      1'h1:
          \word_complete$next  = 1'h1;
      default:
          \word_complete$next  = 1'h0;
    endcase
    casez (rst)
      1'h1:
          \word_complete$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$18 ) begin end
    \word_accepted$next  = 1'h0;
    casez (chip_selected)
      1'h1:
          casez (\$11 )
            1'h1:
                casez (\$15 )
                  1'h1:
                      \word_accepted$next  = 1'h1;
                endcase
          endcase
    endcase
    casez (rst)
      1'h1:
          \word_accepted$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$18 ) begin end
    \current_tx$next  = current_tx;
    \spi_device__sdo$next  = spi_device__sdo;
    casez (\$21 )
      1'h1:
          { \spi_device__sdo$next , \current_tx$next [39:1] } = current_tx;
    endcase
    (* full_case = 32'd1 *)
    casez (chip_selected)
      1'h1:
        begin
          casez (\$25 )
            1'h1:
                casez (\$29 )
                  1'h1:
                      \current_tx$next  = word_out;
                endcase
          endcase
          casez (\$33 )
            1'h1:
                { \spi_device__sdo$next , \current_tx$next [39:1] } = current_tx;
          endcase
        end
      default:
          \current_tx$next  = word_out;
    endcase
    casez (rst)
      1'h1:
        begin
          \current_tx$next  = 40'h0000000000;
          \spi_device__sdo$next  = 1'h0;
        end
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$18 ) begin end
    \bit_count$next  = bit_count;
    (* full_case = 32'd1 *)
    casez (chip_selected)
      1'h1:
          casez (\$37 )
            1'h1:
                \bit_count$next  = \$40 [5:0];
          endcase
      default:
          \bit_count$next  = 6'h00;
    endcase
    casez (rst)
      1'h1:
          \bit_count$next  = 6'h00;
    endcase
  end
  assign \$39  = \$40 ;
  assign \$sample$s$chip_selected$sync$1$next  = chip_selected;
  assign \$sample$s$serial_clock$sync$1$next  = serial_clock;
  assign chip_selected = \$17 ;
  assign \output  = \$7 ;
  assign sample = \$3 ;
  assign serial_clock = spi_device__sck;
endmodule

module spi_master(spi_controller__sdo, spi_controller__sck, spi_controller__cs, start_transfer, word_in, word_out, word_complete, clk, rst, spi_controller__sdi);
  reg \$auto$verilog_backend.cc:2083:dump_module$19  = 0;
  wire \$1 ;
  wire \$11 ;
  wire \$2 ;
  wire \$5 ;
  wire \$6 ;
  wire \$9 ;
  (* \amaranth.sample_reg  = 32'd1 *)
  reg \$sample$s$clock_out$sync$1  = 1'h0;
  wire \$sample$s$clock_out$sync$1$next ;
  input clk;
  wire clk;
  reg cs = 1'h1;
  reg \cs$next ;
  reg [1:0] fsm_state = 2'h1;
  reg [1:0] \fsm_state$next ;
  input rst;
  wire rst;
  wire sck;
  reg sck_divider_clock_enable_in = 1'h0;
  reg \sck_divider_clock_enable_in$next ;
  wire sck_divider_clock_out;
  output spi_controller__cs;
  wire spi_controller__cs;
  output spi_controller__sck;
  wire spi_controller__sck;
  input spi_controller__sdi;
  wire spi_controller__sdi;
  output spi_controller__sdo;
  wire spi_controller__sdo;
  wire spi_device_spi_device__cs;
  wire spi_device_spi_device__sck;
  wire spi_device_spi_device__sdi;
  wire spi_device_spi_device__sdo;
  wire spi_device_word_accepted;
  wire spi_device_word_complete;
  wire [39:0] spi_device_word_in;
  wire [39:0] spi_device_word_out;
  input start_transfer;
  wire start_transfer;
  wire word_accepted;
  output word_complete;
  wire word_complete;
  output [39:0] word_in;
  wire [39:0] word_in;
  input [39:0] word_out;
  wire [39:0] word_out;
  assign \$9  = ~ \$sample$s$clock_out$sync$1 ;
  assign \$11  = \$9  & sck_divider_clock_out;
  assign \$2  = ! fsm_state;
  assign \$1  = \$2  ? sck_divider_clock_out : 1'h0;
  assign \$6  = ! fsm_state;
  assign \$5  = \$6  ? 1'h0 : 1'h1;
  always @(posedge clk)
    \$sample$s$clock_out$sync$1  <= sck_divider_clock_out;
  always @(posedge clk)
    fsm_state <= \fsm_state$next ;
  always @(posedge clk)
    sck_divider_clock_enable_in <= \sck_divider_clock_enable_in$next ;
  always @(posedge clk)
    cs <= \cs$next ;
  sck_divider sck_divider (
    .clk(clk),
    .clock_enable_in(sck_divider_clock_enable_in),
    .clock_out(sck_divider_clock_out),
    .rst(rst)
  );
  spi_device spi_device (
    .clk(clk),
    .rst(rst),
    .spi_device__cs(spi_device_spi_device__cs),
    .spi_device__sck(spi_device_spi_device__sck),
    .spi_device__sdi(spi_device_spi_device__sdi),
    .spi_device__sdo(spi_device_spi_device__sdo),
    .word_accepted(spi_device_word_accepted),
    .word_complete(spi_device_word_complete),
    .word_in(spi_device_word_in),
    .word_out(spi_device_word_out)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$19 ) begin end
    \cs$next  = \$5 ;
    casez (rst)
      1'h1:
          \cs$next  = 1'h1;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$19 ) begin end
    \sck_divider_clock_enable_in$next  = sck_divider_clock_enable_in;
    casez (fsm_state)
      2'h1:
        begin
          \sck_divider_clock_enable_in$next  = 1'h0;
          casez (start_transfer)
            1'h1:
                \sck_divider_clock_enable_in$next  = 1'h1;
          endcase
        end
    endcase
    casez (rst)
      1'h1:
          \sck_divider_clock_enable_in$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$19 ) begin end
    \fsm_state$next  = fsm_state;
    casez (fsm_state)
      2'h1:
          casez (start_transfer)
            1'h1:
                \fsm_state$next  = 2'h2;
          endcase
      2'h2:
          casez (\$11 )
            1'h1:
                \fsm_state$next  = 2'h0;
          endcase
      2'h0:
          casez (spi_device_word_complete)
            1'h1:
                \fsm_state$next  = 2'h1;
          endcase
    endcase
    casez (rst)
      1'h1:
          \fsm_state$next  = 2'h1;
    endcase
  end
  assign \$sample$s$clock_out$sync$1$next  = sck_divider_clock_out;
  assign sck = \$1 ;
  assign word_complete = spi_device_word_complete;
  assign word_accepted = spi_device_word_accepted;
  assign spi_device_word_out = word_out;
  assign word_in = spi_device_word_in;
  assign spi_device_spi_device__cs = cs;
  assign spi_device_spi_device__sck = sck;
  assign spi_device_spi_device__sdi = spi_controller__sdi;
  assign spi_controller__sdo = spi_device_spi_device__sdo;
  assign spi_controller__cs = cs;
  assign spi_controller__sck = sck;
endmodule
